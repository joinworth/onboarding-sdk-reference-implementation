name: Secret Scan (Gitleaks)

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]

jobs:
  gitleaks:
    name: Gitleaks Secret Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks (PR commit range)
        id: gitleaks
        continue-on-error: true
        uses: gitleaks/gitleaks-action@v2
        with:
          args: >
            detect
            --redact
            --report-format json
            --report-path gitleaks.json
            --log-opts=${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }}

      - name: Analyze report
        id: analyze
        if: always()
        shell: bash
        run: |
          if [ -f gitleaks.json ]; then
            node -e "const fs=require('fs'); const d=JSON.parse(fs.readFileSync('gitleaks.json','utf8')||'[]'); process.stdout.write(String(Array.isArray(d)?d.length:0));" > .gitleaks_count
          else
            echo "0" > .gitleaks_count
          fi
          echo "count=$(cat .gitleaks_count)" >> "$GITHUB_OUTPUT"

      - name: Comment on PR (pass/fail)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- gitleaks-secret-scan -->';
            const countFromOutput = Number('${{ steps.analyze.outputs.count }}' || '0');

            /** Basic extra-redaction: avoid printing long token-like strings even if a tool bug occurs. */
            function extraRedact(str) {
              if (!str) return '';
              return String(str)
                .replace(/[A-Za-z0-9+/=_-]{20,}/g, '***')
                .replace(/[A-Fa-f0-9]{32,}/g, '***');
            }

            function summarizeFindings(findings) {
              const max = 10;
              const items = findings.slice(0, max).map((f, idx) => {
                const file = f.File || f.file || 'unknown_file';
                const line = f.StartLine ?? f.startLine ?? f.Line ?? f.line ?? '';
                const rule = f.RuleID || f.ruleID || f.RuleId || f.ruleId || 'unknown_rule';
                const desc = f.Description || f.description || '';
                const match = extraRedact(f.Match || f.match || '');
                const loc = line ? `${file}:${line}` : `${file}`;

                let body = `- ${idx + 1}. \`${loc}\` — **${extraRedact(rule)}**`;
                if (desc) body += ` — ${extraRedact(desc)}`;
                if (match) {
                  body += `\n\n\`\`\`\n${match}\n\`\`\`\n`;
                }
                return body;
              });
              const more = findings.length > max ? `\n\nShowing first ${max} of ${findings.length} findings.` : '';
              return `${items.join('\n')}${more}`;
            }

            let findings = [];
            try {
              if (fs.existsSync('gitleaks.json')) {
                const raw = fs.readFileSync('gitleaks.json', 'utf8') || '[]';
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed)) findings = parsed;
              }
            } catch (e) {
              // If parsing fails, keep findings empty; the job will still fail based on count.
            }

            // Prefer the parsed JSON length for messaging; fall back to the step output.
            const count = Number.isFinite(findings.length) ? findings.length : countFromOutput;

            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const header = count === 0
              ? '✅ Gitleaks secret scan: **Passed**'
              : `❌ Gitleaks secret scan: **Failed** (${count} potential secret${count === 1 ? '' : 's'})`;

            const details = count === 0
              ? ''
              : `\n\n### Findings\n${summarizeFindings(findings)}\n\nSee the workflow run for full details: ${runUrl}`;

            const body = `${marker}\n\n${header}\n\n- Run: ${runUrl}\n${details}\n`;

            const { owner, repo } = context.repo;
            const issue_number = context.payload.pull_request.number;

            // Upsert a single comment to avoid noise.
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner, repo, issue_number, per_page: 100,
            });
            const existing = comments.find(c => (c.body || '').includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

      - name: Fail if secrets detected
        if: always()
        shell: bash
        run: |
          if [ "${{ steps.analyze.outputs.count }}" != "0" ]; then
            echo "Gitleaks found ${{ steps.analyze.outputs.count }} potential secret(s)."
            exit 1
          fi

